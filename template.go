package repository

func (r *Repository) baseTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"errors"
	"sync"

	"gorm.io/gorm"

	"{{.GormDBVarPkg}}"

	"{{.GenQueryPkg}}"
)

var once sync.Once
var q *query.Query

func GetQuery() *query.Query {
	once.Do(func() {
		q = query.Use({{.GormDBVar}})
	})
	return q
}

// IsRealErr 是否为非超时和查询不到的错误
func IsRealErr(err error) bool {
	return !errors.Is(err, gorm.ErrRecordNotFound) &&
		!errors.Is(err, context.DeadlineExceeded) &&
		!errors.Is(err, context.Canceled)
}
`
}

func (r *Repository) genBaseTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
{{range .Imports}}{{.}}{{end}}
)

// {{.StructName}} 仓库/Repository
type {{.StructName}} struct {
	q            *query.Query
	db           *gorm.DB
	logger       *zap.Logger
	unscoped     bool
	newTableName *string
}

// Option {{.StructName}}仓库初始化选项
type Option func(*{{.StructName}})

func WithQuery(q *query.Query) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.q = q
	}
}

func WithLogger(logger *zap.Logger) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.logger = logger
	}
}

func WithDB(db *gorm.DB) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.db = db
	}
}

func WithNewTableName(newTableName string) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.newTableName = &newTableName
	}
}

func WithUnscoped() Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.unscoped = true
	}
}

// New {{.StructName}}仓库初始化
func New(opts ...Option) *{{.StructName}} {
	{{.Abbr}} := &{{.StructName}}{
		q:      {{.RepoPkgName}}.GetQuery(),
		db:     {{.GormDBVar}},
		logger: {{.ZapVar}},
	}
	for _, opt := range opts {
		opt({{.Abbr}})
	}
	return {{.Abbr}}
}

// ConditionOption 字段条件筛选选项
type ConditionOption func(*{{.StructName}}) gen.Condition

// Condition 自定义字段条件筛选
func Condition(condition gen.Condition) ConditionOption {
	return func(*{{.StructName}}) gen.Condition {
		return condition
	}
}
{{range .Conditions}}{{.}}{{end}}
// UpdateOption 数据更新选项
type UpdateOption func(*{{.StructName}}) field.AssignExpr

// Update 自定义数据更新
func Update(update field.AssignExpr) UpdateOption {
	return func(*{{.StructName}}) field.AssignExpr {
		return update
	}
}
{{range .Updates}}{{.}}{{end}}
// OrderOption 数据排序选项
type OrderOption func(*{{.StructName}}) field.Expr

// Order 自定义数据排序
func OrderBy(order field.Expr) OrderOption {
	return func(*{{.StructName}}) field.Expr {
		return order
	}
}
{{range .Orders}}{{.}}{{end}}
// RelationOption 关联模型预加载选项
type RelationOption func(*{{.StructName}}) field.RelationField

// Relation 自定义关联模型预加载
func Relation(relation field.RelationField) RelationOption {
	return func(*{{.StructName}}) field.RelationField {
		return relation
	}
}

func RelationAll() RelationOption {
	return func(*{{.StructName}}) field.RelationField {
		return field.Associations
	}
}
`
}

func (r *Repository) genCountTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _count struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// Count 获取数据总记录
func ({{.Abbr}} *{{.StructName}}) Count() *_count {
	return &_count{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (c *_count) Tx(tx *query.Query) *_count {
	c.tx = tx
	if tx != nil {
		c.qTx = nil
	}
	return c
}

// QueryTx 设置为手动事务
func (c *_count) QueryTx(tx *query.QueryTx) *_count {
	c.qTx = tx
	if tx != nil {
		c.tx = nil
	}
	return c
}

func (c *_count) Unscoped() *_count {
	c.unscoped = true
	return c
}

func (c *_count) Scopes(funcs ...func(gen.Dao) gen.Dao) *_count {
	c.scopes = append(c.scopes, funcs...)
	return c
}

func (c *_count) Where(opts ...ConditionOption) *_count {
	c.conditionOpts = append(c.conditionOpts, opts...)
	return c
}

func (c *_count) WriteDB() *_count {
	c.writeDB = true
	return c
}

// Do 执行获取数据总记录
func (c *_count) Do(ctx context.Context) (int64, error) {
	cq := c.core.q.{{.StructName}}
	if c.tx != nil {
		cq = c.tx.{{.StructName}}
	}
	if c.qTx != nil {
		cq = c.qTx.{{.StructName}}
	}
	cr := cq.WithContext(ctx)
	if c.core.newTableName != nil && *c.core.newTableName != "" {
		cr = cq.Table(*c.core.newTableName).WithContext(ctx)
	}
	if c.writeDB {
		cr = cr.WriteDB()
	}
	if c.unscoped {
		cr = cr.Unscoped()
	}
	if len(c.scopes) > 0 {
		cr = cr.Scopes(c.scopes...)
	}
	if _len := len(c.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range c.conditionOpts {
			conditions = append(conditions, opt(c.core))
		}
		if len(conditions) > 0 {
			cr = cr.Where(conditions...)
		}
	}
	count, err := cr.Count()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			c.core.logger.Error("【{{.StructName}}.Count】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return 0, err
	}
	return count, nil
}
`
}

func (r *Repository) genCreateTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _create struct {
	core      *{{.StructName}}
	tx        *query.Query
	qTx       *query.QueryTx
	unscoped  bool
	values    []*{{.ModelName}}.{{.StructName}}
	batchSize int
	scopes    []func(gen.Dao) gen.Dao
}

// Create 添加数据
func ({{.Abbr}} *{{.StructName}}) Create() *_create {
	return &_create{
		core:     {{.Abbr}},
		unscoped: {{.Abbr}}.unscoped,
		values:   make([]*{{.ModelName}}.{{.StructName}}, 0),
		scopes:   make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (c *_create) Tx(tx *query.Query) *_create {
	c.tx = tx
	if tx != nil {
		c.qTx = nil
	}
	return c
}

// QueryTx 设置为手动事务
func (c *_create) QueryTx(tx *query.QueryTx) *_create {
	c.qTx = tx
	if tx != nil {
		c.tx = nil
	}
	return c
}

func (c *_create) Unscoped() *_create {
	c.unscoped = true
	return c
}

func (c *_create) Scopes(funcs ...func(gen.Dao) gen.Dao) *_create {
	c.scopes = append(c.scopes, funcs...)
	return c
}

func (c *_create) Values(values ...*{{.ModelName}}.{{.StructName}}) *_create {
	c.values = append(c.values, values...)
	return c
}

// BatchSize 当批量插入时指定创建的数量
func (c *_create) BatchSize(batchSize uint) *_create {
	c.batchSize = int(batchSize)
	return c
}

// Do 执行添加数据
func (c *_create) Do(ctx context.Context) (err error) {
	length := len(c.values)
	if length == 0 {
		return nil
	}
	cq := c.core.q.{{.StructName}}
	if c.tx != nil {
		cq = c.tx.{{.StructName}}
	}
	if c.qTx != nil {
		cq = c.qTx.{{.StructName}}
	}
	cr := cq.WithContext(ctx)
	if c.core.newTableName != nil && *c.core.newTableName != "" {
		cr = cq.Table(*c.core.newTableName).WithContext(ctx)
	}
	if c.unscoped {
		cr = cr.Unscoped()
	}
	if len(c.scopes) > 0 {
		cr = cr.Scopes(c.scopes...)
	}
	if length > 1 && c.batchSize > 0 {
		err = cr.CreateInBatches(c.values, c.batchSize)
	} else {
		err = cr.Create(c.values...)
	}
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			c.core.logger.Error("【{{.StructName}}.Create】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return err
	}
	return nil
}
`
}

func (r *Repository) genDeleteTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _delete struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
	scopes        []func(gen.Dao) gen.Dao
}

// Delete 删除数据
func ({{.Abbr}} *{{.StructName}}) Delete() *_delete {
	return &_delete{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (d *_delete) Tx(tx *query.Query) *_delete {
	d.tx = tx
	if tx != nil {
		d.qTx = nil
	}
	return d
}

// QueryTx 设置为手动事务
func (d *_delete) QueryTx(tx *query.QueryTx) *_delete {
	d.qTx = tx
	if tx != nil {
		d.tx = nil
	}
	return d
}

func (d *_delete) Unscoped() *_delete {
	d.unscoped = true
	return d
}

func (d *_delete) Scopes(funcs ...func(gen.Dao) gen.Dao) *_delete {
	d.scopes = append(d.scopes, funcs...)
	return d
}

func (d *_delete) Where(opts ...ConditionOption) *_delete {
	d.conditionOpts = append(d.conditionOpts, opts...)
	return d
}

// Do 执行删除数据
func (d *_delete) Do(ctx context.Context) (int64, error) {
	dq := d.core.q.{{.StructName}}
	if d.tx != nil {
		dq = d.tx.{{.StructName}}
	}
	if d.qTx != nil {
		dq = d.qTx.{{.StructName}}
	}
	dr := dq.WithContext(ctx)
	if d.core.newTableName != nil && *d.core.newTableName != "" {
		dr = dq.Table(*d.core.newTableName).WithContext(ctx)
	}
	if d.unscoped {
		dr = dr.Unscoped()
	}
	if len(d.scopes) > 0 {
		dr = dr.Scopes(d.scopes...)
	}
	if _len := len(d.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range d.conditionOpts {
			conditions = append(conditions, opt(d.core))
		}
		if len(conditions) > 0 {
			dr = dr.Where(conditions...)
		}
	}
	res, err := dr.Delete()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			d.core.logger.Error("【{{.StructName}}.Delete】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return 0, err
	}
	return res.RowsAffected, nil
}
`
}

func (r *Repository) genFirstTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _first struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// First 获取第一条记录（主键升序）
func ({{.Abbr}} *{{.StructName}}) First() *_first {
	return &_first{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (f *_first) Tx(tx *query.Query) *_first {
	f.tx = tx
	if tx != nil {
		f.qTx = nil
	}
	return f
}

// QueryTx 设置为手动事务
func (f *_first) QueryTx(tx *query.QueryTx) *_first {
	f.qTx = tx
	if tx != nil {
		f.tx = nil
	}
	return f
}

func (f *_first) Select(field ...field.Expr) *_first {
	f.selects = append(f.selects, field...)
	return f
}

func (f *_first) ForUpdate() *_first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return f
}

func (f *_first) ForUpdateSkipLocked() *_first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *_first) ForUpdateNoWait() *_first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *_first) ForShare() *_first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return f
}

func (f *_first) ForShareSkipLocked() *_first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *_first) ForShareNoWait() *_first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *_first) Unscoped() *_first {
	f.unscoped = true
	return f
}

func (f *_first) Scopes(funcs ...func(gen.Dao) gen.Dao) *_first {
	f.scopes = append(f.scopes, funcs...)
	return f
}

func (f *_first) Relation(opts ...RelationOption) *_first {
	f.relationOpts = append(f.relationOpts, opts...)
	return f
}

func (f *_first) Where(opts ...ConditionOption) *_first {
	f.conditionOpts = append(f.conditionOpts, opts...)
	return f
}

func (f *_first) WriteDB() *_first {
	f.writeDB = true
	return f
}

// Do 执行获取第一条记录（主键升序）
func (f *_first) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	fq := f.core.q.{{.StructName}}
	if f.tx != nil {
		fq = f.tx.{{.StructName}}
	}
	if f.qTx != nil {
		fq = f.qTx.{{.StructName}}
	}
	fr := fq.WithContext(ctx)
	if f.core.newTableName != nil && *f.core.newTableName != "" {
		fr = fq.Table(*f.core.newTableName).WithContext(ctx)
	}
	if _len := len(f.selects); _len > 0 {
		if f.core.newTableName == nil {
			fr = fr.Select(f.selects...)
		} else {
			fs := make([]field.Expr, 0, _len)
			for _, v := range f.selects {
				fs = append(fs, field.NewField(*f.core.newTableName, v.ColumnName().String()))
			}
			fr = fr.Select(fs...)
		}
	}
	if f.writeDB {
		fr = fr.WriteDB()
	}
	if f.unscoped {
		fr = fr.Unscoped()
	}
	if len(f.scopes) > 0 {
		fr = fr.Scopes(f.scopes...)
	}
	if (f.tx != nil || f.qTx != nil) && f.lock != nil {
		fr = fr.Clauses(f.lock)
	}
	if _len := len(f.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range f.conditionOpts {
			conditions = append(conditions, opt(f.core))
		}
		if len(conditions) > 0 {
			fr = fr.Where(conditions...)
		}
	}
	if _len := len(f.relationOpts); _len > 0 {
		relations := make([]field.RelationField, 0, _len)
		for _, opt := range f.relationOpts {
			relations = append(relations, opt(f.core))
		}
		if len(relations) > 0 {
			fr = fr.Preload(relations...)
		}
	}
	res, err := fr.First()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			f.core.logger.Error("【{{.StructName}}.First】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genLastTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _last struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// Last 获取最后一条记录（主键降序）
func ({{.Abbr}} *{{.StructName}}) Last() *_last {
	return &_last{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (l *_last) Tx(tx *query.Query) *_last {
	l.tx = tx
	if tx != nil {
		l.qTx = nil
	}
	return l
}

// QueryTx 设置为手动事务
func (l *_last) QueryTx(tx *query.QueryTx) *_last {
	l.qTx = tx
	if tx != nil {
		l.tx = nil
	}
	return l
}

func (l *_last) Select(field ...field.Expr) *_last {
	l.selects = append(l.selects, field...)
	return l
}

func (l *_last) ForUpdate() *_last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *_last) ForUpdateSkipLocked() *_last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_last) ForUpdateNoWait() *_last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_last) ForShare() *_last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *_last) ForShareSkipLocked() *_last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_last) ForShareNoWait() *_last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_last) Unscoped() *_last {
	l.unscoped = true
	return l
}

func (l *_last) Scopes(funcs ...func(gen.Dao) gen.Dao) *_last {
	l.scopes = append(l.scopes, funcs...)
	return l
}

func (l *_last) Relation(opts ...RelationOption) *_last {
	l.relationOpts = append(l.relationOpts, opts...)
	return l
}

func (l *_last) Where(opts ...ConditionOption) *_last {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

func (l *_last) WriteDB() *_last {
	l.writeDB = true
	return l
}

// Do 执行获取最后一条记录（主键降序）
func (l *_last) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	lq := l.core.q.{{.StructName}}
	if l.tx != nil {
		lq = l.tx.{{.StructName}}
	}
	if l.qTx != nil {
		lq = l.qTx.{{.StructName}}
	}
	lr := lq.WithContext(ctx)
	if l.core.newTableName != nil && *l.core.newTableName != "" {
		lr = lq.Table(*l.core.newTableName).WithContext(ctx)
	}
	if _len := len(l.selects); _len > 0 {
		if l.core.newTableName == nil {
			lr = lr.Select(l.selects...)
		} else {
			fs := make([]field.Expr, 0, _len)
			for _, v := range l.selects {
				fs = append(fs, field.NewField(*l.core.newTableName, v.ColumnName().String()))
			}
			lr = lr.Select(fs...)
		}
	}
	if l.writeDB {
		lr = lr.WriteDB()
	}
	if l.unscoped {
		lr = lr.Unscoped()
	}
	if len(l.scopes) > 0 {
		lr = lr.Scopes(l.scopes...)
	}
	if (l.tx != nil || l.qTx != nil) && l.lock != nil {
		lr = lr.Clauses(l.lock)
	}
	if _len := len(l.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range l.conditionOpts {
			conditions = append(conditions, opt(l.core))
		}
		if len(conditions) > 0 {
			lr = lr.Where(conditions...)
		}
	}
	if _len := len(l.relationOpts); _len > 0 {
		relations := make([]field.RelationField, 0, _len)
		for _, opt := range l.relationOpts {
			relations = append(relations, opt(l.core))
		}
		if len(relations) > 0 {
			lr = lr.Preload(relations...)
		}
	}
	res, err := lr.Last()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			l.core.logger.Error("【{{.StructName}}.Last】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genListTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	page "github.com/gorm-gen/paginate/gen"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _list struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// List 获取数据列表
func ({{.Abbr}} *{{.StructName}}) List() *_list {
	return &_list{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (l *_list) Tx(tx *query.Query) *_list {
	l.tx = tx
	if tx != nil {
		l.qTx = nil
	}
	return l
}

// QueryTx 设置为手动事务
func (l *_list) QueryTx(tx *query.QueryTx) *_list {
	l.qTx = tx
	if tx != nil {
		l.tx = nil
	}
	return l
}

func (l *_list) Select(field ...field.Expr) *_list {
	l.selects = append(l.selects, field...)
	return l
}

func (l *_list) ForUpdate() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *_list) ForUpdateSkipLocked() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_list) ForUpdateNoWait() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_list) ForShare() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *_list) ForShareSkipLocked() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_list) ForShareNoWait() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_list) Unscoped() *_list {
	l.unscoped = true
	return l
}

func (l *_list) Scopes(funcs ...func(gen.Dao) gen.Dao) *_list {
	l.scopes = append(l.scopes, funcs...)
	return l
}

func (l *_list) Relation(opts ...RelationOption) *_list {
	l.relationOpts = append(l.relationOpts, opts...)
	return l
}

func (l *_list) Order(opts ...OrderOption) *_list {
	l.orderOpts = append(l.orderOpts, opts...)
	return l
}

func (l *_list) Where(opts ...ConditionOption) *_list {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

func (l *_list) WriteDB() *_list {
	l.writeDB = true
	return l
}

// Page 列表分页
func (l *_list) Page(page, pageSize uint) *_list {
	l.page = int(page)
	l.pageSize = int(pageSize)
	return l
}

// Do 执行获取数据列表
func (l *_list) Do(ctx context.Context) ([]*{{.ModelName}}.{{.StructName}}, error) {
	lq := l.core.q.{{.StructName}}
	if l.tx != nil {
		lq = l.tx.{{.StructName}}
	}
	if l.qTx != nil {
		lq = l.qTx.{{.StructName}}
	}
	lr := lq.WithContext(ctx)
	if l.core.newTableName != nil && *l.core.newTableName != "" {
		lr = lq.Table(*l.core.newTableName).WithContext(ctx)
	}
	if _len := len(l.selects); _len > 0 {
		if l.core.newTableName == nil {
			lr = lr.Select(l.selects...)
		} else {
			fs := make([]field.Expr, 0, _len)
			for _, v := range l.selects {
				fs = append(fs, field.NewField(*l.core.newTableName, v.ColumnName().String()))
			}
			lr = lr.Select(fs...)
		}
	}
	if l.writeDB {
		lr = lr.WriteDB()
	}
	if l.unscoped {
		lr = lr.Unscoped()
	}
	if len(l.scopes) > 0 {
		lr = lr.Scopes(l.scopes...)
	}
	if (l.tx != nil || l.qTx != nil) && l.lock != nil {
		lr = lr.Clauses(l.lock)
	}
	if _len := len(l.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range l.conditionOpts {
			conditions = append(conditions, opt(l.core))
		}
		if len(conditions) > 0 {
			lr = lr.Where(conditions...)
		}
	}
	if _len := len(l.orderOpts); _len > 0 {
		orders := make([]field.Expr, 0, _len)
		for _, opt := range l.orderOpts {
			orders = append(orders, opt(l.core))
		}
		if len(orders) > 0 {
			lr = lr.Order(orders...)
		}
	}
	if l.page > 0 && l.pageSize > 0 {
		lr = lr.Scopes(page.Paginate(l.page, l.pageSize))
	}
	if _len := len(l.relationOpts); _len > 0 {
		relations := make([]field.RelationField, 0, _len)
		for _, opt := range l.relationOpts {
			relations = append(relations, opt(l.core))
		}
		if len(relations) > 0 {
			lr = lr.Preload(relations...)
		}
	}
	list, err := lr.Find()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			l.core.logger.Error("【{{.StructName}}.List】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return nil, err
	}
	return list, nil
}
`
}

func (r *Repository) genTakeTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _take struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// Take 获取一条记录
func ({{.Abbr}} *{{.StructName}}) Take() *_take {
	return &_take{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (t *_take) Tx(tx *query.Query) *_take {
	t.tx = tx
	if tx != nil {
		t.qTx = nil
	}
	return t
}

// QueryTx 设置为手动事务
func (t *_take) QueryTx(tx *query.QueryTx) *_take {
	t.qTx = tx
	if tx != nil {
		t.tx = nil
	}
	return t
}

func (t *_take) Select(field ...field.Expr) *_take {
	t.selects = append(t.selects, field...)
	return t
}

func (t *_take) ForUpdate() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return t
}

func (t *_take) ForUpdateSkipLocked() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_take) ForUpdateNoWait() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_take) ForShare() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return t
}

func (t *_take) ForShareSkipLocked() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_take) ForShareNoWait() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_take) Unscoped() *_take {
	t.unscoped = true
	return t
}

func (t *_take) Scopes(funcs ...func(gen.Dao) gen.Dao) *_take {
	t.scopes = append(t.scopes, funcs...)
	return t
}

func (t *_take) Relation(opts ...RelationOption) *_take {
	t.relationOpts = append(t.relationOpts, opts...)
	return t
}

func (t *_take) Order(opts ...OrderOption) *_take {
	t.orderOpts = append(t.orderOpts, opts...)
	return t
}

func (t *_take) Where(opts ...ConditionOption) *_take {
	t.conditionOpts = append(t.conditionOpts, opts...)
	return t
}

func (t *_take) WriteDB() *_take {
	t.writeDB = true
	return t
}

// Do 执行获取一条记录
func (t *_take) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	tq := t.core.q.{{.StructName}}
	if t.tx != nil {
		tq = t.tx.{{.StructName}}
	}
	if t.qTx != nil {
		tq = t.qTx.{{.StructName}}
	}
	tr := tq.WithContext(ctx)
	if t.core.newTableName != nil && *t.core.newTableName != "" {
		tr = tq.Table(*t.core.newTableName).WithContext(ctx)
	}
	if _len := len(t.selects); _len > 0 {
		if t.core.newTableName == nil {
			tr = tr.Select(t.selects...)
		} else {
			fs := make([]field.Expr, 0, _len)
			for _, v := range t.selects {
				fs = append(fs, field.NewField(*t.core.newTableName, v.ColumnName().String()))
			}
			tr = tr.Select(fs...)
		}
	}
	if t.writeDB {
		tr = tr.WriteDB()
	}
	if t.unscoped {
		tr = tr.Unscoped()
	}
	if len(t.scopes) > 0 {
		tr = tr.Scopes(t.scopes...)
	}
	if (t.tx != nil || t.qTx != nil) && t.lock != nil {
		tr = tr.Clauses(t.lock)
	}
	if _len := len(t.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range t.conditionOpts {
			conditions = append(conditions, opt(t.core))
		}
		if len(conditions) > 0 {
			tr = tr.Where(conditions...)
		}
	}
	if _len := len(t.orderOpts); _len > 0 {
		orders := make([]field.Expr, 0, _len)
		for _, opt := range t.orderOpts {
			orders = append(orders, opt(t.core))
		}
		if len(orders) > 0 {
			tr = tr.Order(orders...)
		}
	}
	if _len := len(t.relationOpts); _len > 0 {
		relations := make([]field.RelationField, 0, _len)
		for _, opt := range t.relationOpts {
			relations = append(relations, opt(t.core))
		}
		if len(relations) > 0 {
			tr = tr.Preload(relations...)
		}
	}
	res, err := tr.Take()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			t.core.logger.Error("【{{.StructName}}.Take】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genUpdateTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _update struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	updateOpts    []UpdateOption
	conditionOpts []ConditionOption
	scopes        []func(gen.Dao) gen.Dao
}

// Update 更新数据
func ({{.Abbr}} *{{.StructName}}) Update() *_update {
	return &_update{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		updateOpts:    make([]UpdateOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (u *_update) Tx(tx *query.Query) *_update {
	u.tx = tx
	if tx != nil {
		u.qTx = nil
	}
	return u
}

// QueryTx 设置为手动事务
func (u *_update) QueryTx(tx *query.QueryTx) *_update {
	u.qTx = tx
	if tx != nil {
		u.tx = nil
	}
	return u
}

func (u *_update) Unscoped() *_update {
	u.unscoped = true
	return u
}

func (u *_update) Scopes(funcs ...func(gen.Dao) gen.Dao) *_update {
	u.scopes = append(u.scopes, funcs...)
	return u
}

func (u *_update) Update(opts ...UpdateOption) *_update {
	u.updateOpts = append(u.updateOpts, opts...)
	return u
}

func (u *_update) Where(opts ...ConditionOption) *_update {
	u.conditionOpts = append(u.conditionOpts, opts...)
	return u
}

// Do 执行更新数据
func (u *_update) Do(ctx context.Context) (int64, error) {
	_length := len(u.updateOpts)
	if _length == 0 {
		return 0, nil
	}
	uq := u.core.q.{{.StructName}}
	if u.tx != nil {
		uq = u.tx.{{.StructName}}
	}
	if u.qTx != nil {
		uq = u.qTx.{{.StructName}}
	}
	ur := uq.WithContext(ctx)
	if u.core.newTableName != nil && *u.core.newTableName != "" {
		ur = uq.Table(*u.core.newTableName).WithContext(ctx)
	}
	if u.unscoped {
		ur = ur.Unscoped()
	}
	if len(u.scopes) > 0 {
		ur = ur.Scopes(u.scopes...)
	}
	if _len := len(u.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range u.conditionOpts {
			conditions = append(conditions, opt(u.core))
		}
		if len(conditions) > 0 {
			ur = ur.Where(conditions...)
		}
	}
	columns := make([]field.AssignExpr, 0, _length)
	for _, opt := range u.updateOpts {
		columns = append(columns, opt(u.core))
	}
	if len(columns) == 0 {
		return 0, nil
	}
	res, err := ur.UpdateSimple(columns...)
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			u.core.logger.Error("【{{.StructName}}.Update】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return 0, err
	}
	return res.RowsAffected, nil
}
`
}

func (r *Repository) genSumTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	"github.com/shopspring/decimal"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _sum struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	genField      field.Expr
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// Sum SUM数据
func ({{.Abbr}} *{{.StructName}}) Sum(genField field.Expr) *_sum {
	return &_sum{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		genField:      genField,
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (s *_sum) Tx(tx *query.Query) *_sum {
	s.tx = tx
	if tx != nil {
		s.qTx = nil
	}
	return s
}

// QueryTx 设置为手动事务
func (s *_sum) QueryTx(tx *query.QueryTx) *_sum {
	s.qTx = tx
	if tx != nil {
		s.tx = nil
	}
	return s
}

func (s *_sum) Unscoped() *_sum {
	s.unscoped = true
	return s
}

func (s *_sum) Scopes(funcs ...func(gen.Dao) gen.Dao) *_sum {
	s.scopes = append(s.scopes, funcs...)
	return s
}

func (s *_sum) WriteDB() *_sum {
	s.writeDB = true
	return s
}

func (s *_sum) Where(opts ...ConditionOption) *_sum {
	s.conditionOpts = append(s.conditionOpts, opts...)
	return s
}
` + "\ntype Sum struct {\n    Sum decimal.Decimal `json:\"sum\"`\n}\n\n" + `// Do 执行SUM数据
func (s *_sum) Do(ctx context.Context) (decimal.Decimal, error) {
	sq := s.core.q.{{.StructName}}
	if s.tx != nil {
		sq = s.tx.{{.StructName}}
	}
	if s.qTx != nil {
		sq = s.qTx.{{.StructName}}
	}
	expr := field.NewField("", s.genField.ColumnName().String()).Sum().As("sum")
	sr := sq.WithContext(ctx)
	if s.core.newTableName != nil && *s.core.newTableName != "" {
		sr = sq.Table(*s.core.newTableName).WithContext(ctx)
	}
	sr = sr.Select(expr)
	if s.writeDB {
		sr = sr.WriteDB()
	}
	if s.unscoped {
		sr = sr.Unscoped()
	}
	if len(s.scopes) > 0 {
		sr = sr.Scopes(s.scopes...)
	}
	if _len := len(s.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range s.conditionOpts {
			conditions = append(conditions, opt(s.core))
		}
		if len(conditions) > 0 {
			sr = sr.Where(conditions...)
		}
	}
	var data Sum
	if err := sr.Scan(&data); err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			s.core.logger.Error("【{{.StructName}}.Sum】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return decimal.Zero, err
	}
	return data.Sum, nil
}
`
}

func (r *Repository) genPluckTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	page "github.com/gorm-gen/paginate/gen"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _pluck struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	lock          clause.Expression
	genField      field.Expr
	dest          interface{}
	scopes        []func(gen.Dao) gen.Dao
	unscoped      bool
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	writeDB       bool
}

// Pluck 从数据库中查询单列并扫描结果到切片
func ({{.Abbr}} *{{.StructName}}) Pluck(genField field.Expr, dest interface{}) *_pluck {
	return &_pluck{
		core:          {{.Abbr}},
		genField:      genField,
		dest:          dest,
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
		unscoped:      {{.Abbr}}.unscoped,
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (p *_pluck) Tx(tx *query.Query) *_pluck {
	p.tx = tx
	if tx != nil {
		p.qTx = nil
	}
	return p
}

// QueryTx 设置为手动事务
func (p *_pluck) QueryTx(tx *query.QueryTx) *_pluck {
	p.qTx = tx
	if tx != nil {
		p.tx = nil
	}
	return p
}

func (p *_pluck) ForUpdate() *_pluck {
	p.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return p
}

func (p *_pluck) ForUpdateSkipLocked() *_pluck {
	p.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return p
}

func (p *_pluck) ForUpdateNoWait() *_pluck {
	p.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return p
}

func (p *_pluck) ForShare() *_pluck {
	p.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return p
}

func (p *_pluck) ForShareSkipLocked() *_pluck {
	p.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return p
}

func (p *_pluck) ForShareNoWait() *_pluck {
	p.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return p
}

func (p *_pluck) Unscoped() *_pluck {
	p.unscoped = true
	return p
}

func (p *_pluck) Order(opts ...OrderOption) *_pluck {
	p.orderOpts = append(p.orderOpts, opts...)
	return p
}

// Page 列表分页
func (p *_pluck) Page(page, pageSize uint) *_pluck {
	p.page = int(page)
	p.pageSize = int(pageSize)
	return p
}

func (p *_pluck) Where(opts ...ConditionOption) *_pluck {
	p.conditionOpts = append(p.conditionOpts, opts...)
	return p
}

func (p *_pluck) WriteDB() *_pluck {
	p.writeDB = true
	return p
}

func (p *_pluck) Scopes(funcs ...func(gen.Dao) gen.Dao) *_pluck {
	p.scopes = append(p.scopes, funcs...)
	return p
}

// Do 执行从数据库中查询单列并扫描结果到切片
func (p *_pluck) Do(ctx context.Context) error {
	pq := p.core.q.{{.StructName}}
	if p.tx != nil {
		pq = p.tx.{{.StructName}}
	}
	if p.qTx != nil {
		pq = p.qTx.{{.StructName}}
	}
	pr := pq.WithContext(ctx)
	if p.core.newTableName != nil && *p.core.newTableName != "" {
		pr = pq.Table(*p.core.newTableName).WithContext(ctx)
	}
	if p.writeDB {
		pr = pr.WriteDB()
	}
	if p.unscoped {
		pr = pr.Unscoped()
	}
	if len(p.scopes) > 0 {
		pr = pr.Scopes(p.scopes...)
	}
	if (p.tx != nil || p.qTx != nil) && p.lock != nil {
		pr = pr.Clauses(p.lock)
	}
	if _len := len(p.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range p.conditionOpts {
			conditions = append(conditions, opt(p.core))
		}
		if len(conditions) > 0 {
			pr = pr.Where(conditions...)
		}
	}
	if _len := len(p.orderOpts); _len > 0 {
		orders := make([]field.Expr, 0, _len)
		for _, opt := range p.orderOpts {
			orders = append(orders, opt(p.core))
		}
		if len(orders) > 0 {
			pr = pr.Order(orders...)
		}
	}
	if p.page > 0 && p.pageSize > 0 {
		pr = pr.Scopes(page.Paginate(p.page, p.pageSize))
	}
	column := field.NewField("", p.genField.ColumnName().String())
	if err := pr.Pluck(column, p.dest); err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			p.core.logger.Error("【{{.StructName}}.Pluck】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return err
	}
	return nil
}
`
}

func (r *Repository) genScanTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"runtime/debug"

	page "github.com/gorm-gen/paginate/gen"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _scan struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	lock          clause.Expression
	dest          interface{}
	scopes        []func(gen.Dao) gen.Dao
	selects       []field.Expr
	unscoped      bool
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	writeDB       bool
}

// Scan 从数据库中查询多个列并扫描结果到切片
func ({{.Abbr}} *{{.StructName}}) Scan(dest interface{}) *_scan {
	return &_scan{
		core:          {{.Abbr}},
		dest:          dest,
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
		selects:       make([]field.Expr, 0),
		unscoped:      {{.Abbr}}.unscoped,
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (s *_scan) Tx(tx *query.Query) *_scan {
	s.tx = tx
	if tx != nil {
		s.qTx = nil
	}
	return s
}

// QueryTx 设置为手动事务
func (s *_scan) QueryTx(tx *query.QueryTx) *_scan {
	s.qTx = tx
	if tx != nil {
		s.tx = nil
	}
	return s
}

func (s *_scan) Select(field ...field.Expr) *_scan {
	s.selects = append(s.selects, field...)
	return s
}

func (s *_scan) ForUpdate() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return s
}

func (s *_scan) ForUpdateSkipLocked() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return s
}

func (s *_scan) ForUpdateNoWait() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return s
}

func (s *_scan) ForShare() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return s
}

func (s *_scan) ForShareSkipLocked() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return s
}

func (s *_scan) ForShareNoWait() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return s
}

func (s *_scan) Unscoped() *_scan {
	s.unscoped = true
	return s
}

func (s *_scan) Order(opts ...OrderOption) *_scan {
	s.orderOpts = append(s.orderOpts, opts...)
	return s
}

// Page 列表分页
func (s *_scan) Page(page, pageSize uint) *_scan {
	s.page = int(page)
	s.pageSize = int(pageSize)
	return s
}

func (s *_scan) Where(opts ...ConditionOption) *_scan {
	s.conditionOpts = append(s.conditionOpts, opts...)
	return s
}

func (s *_scan) WriteDB() *_scan {
	s.writeDB = true
	return s
}

func (s *_scan) Scopes(funcs ...func(gen.Dao) gen.Dao) *_scan {
	s.scopes = append(s.scopes, funcs...)
	return s
}

// Do 执行从数据库中查询多个列并扫描结果到切片
func (s *_scan) Do(ctx context.Context) error {
	sq := s.core.q.{{.StructName}}
	if s.tx != nil {
		sq = s.tx.{{.StructName}}
	}
	if s.qTx != nil {
		sq = s.qTx.{{.StructName}}
	}
	sr := sq.WithContext(ctx)
	if s.core.newTableName != nil && *s.core.newTableName != "" {
		sr = sq.Table(*s.core.newTableName).WithContext(ctx)
	}
	if _len := len(s.selects); _len > 0 {
		sr = sr.Select(s.selects...)
	}
	if s.writeDB {
		sr = sr.WriteDB()
	}
	if s.unscoped {
		sr = sr.Unscoped()
	}
	if len(s.scopes) > 0 {
		sr = sr.Scopes(s.scopes...)
	}
	if (s.tx != nil || s.qTx != nil) && s.lock != nil {
		sr = sr.Clauses(s.lock)
	}
	if _len := len(s.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range s.conditionOpts {
			conditions = append(conditions, opt(s.core))
		}
		if len(conditions) > 0 {
			sr = sr.Where(conditions...)
		}
	}
	if _len := len(s.orderOpts); _len > 0 {
		orders := make([]field.Expr, 0, _len)
		for _, opt := range s.orderOpts {
			orders = append(orders, opt(s.core))
		}
		if len(orders) > 0 {
			sr = sr.Order(orders...)
		}
	}
	if s.page > 0 && s.pageSize > 0 {
		sr = sr.Scopes(page.Paginate(s.page, s.pageSize))
	}
	if err := sr.Scan(s.dest); err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			s.core.logger.Error("【{{.StructName}}.Scan】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return err
	}
	return nil
}
`
}

func (r *Repository) genShardingCountTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _shardingCount struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingCount 获取分表数据总记录
func ({{.Abbr}} *{{.StructName}}) ShardingCount(sharding []{{.ShardingKeyType}}) *_shardingCount {
	return &_shardingCount{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (c *_shardingCount) Worker(worker chan struct{}) *_shardingCount {
	if worker == nil {
		return c
	}
	c.worker = worker
	return c
}

// Tx 设置为事务
func (c *_shardingCount) Tx(tx *query.Query) *_shardingCount {
	c.tx = tx
	c.qTx = nil
	return c
}

// QueryTx 设置为手动事务
func (c *_shardingCount) QueryTx(tx *query.QueryTx) *_shardingCount {
	c.qTx = tx
	c.tx = nil
	return c
}

func (c *_shardingCount) Unscoped() *_shardingCount {
	c.unscoped = true
	return c
}

func (c *_shardingCount) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingCount {
	c.scopes = append(c.scopes, funcs...)
	return c
}

func (c *_shardingCount) Where(opts ...ConditionOption) *_shardingCount {
	c.conditionOpts = append(c.conditionOpts, opts...)
	return c
}

func (c *_shardingCount) WriteDB() *_shardingCount {
	c.writeDB = true
	return c
}

// Do 执行获取分表数据总记录
func (c *_shardingCount) Do(ctx context.Context) (int64, map[{{.ShardingKeyType}}]int64, error) {
	_lenSharding := len(c.sharding)
	if _lenSharding == 0 {
		return 0, nil, nil
	}
	cq := c.core.q.{{.StructName}}
	if c.tx != nil {
		cq = c.tx.{{.StructName}}
	}
	if c.qTx != nil {
		cq = c.qTx.{{.StructName}}
	}
	var conditions []gen.Condition
	if _len := len(c.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range c.conditionOpts {
			conditions = append(conditions, opt(c.core))
		}
	}
	sm := sync.Map{}
	wg := sync.WaitGroup{}
	errChan := make(chan error)
	endChan := make(chan struct{})
	for _, sharding := range c.sharding {
		c.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		go func(sharding {{.ShardingKeyType}}) {
			defer func() {
				if r := recover(); r != nil {
					c.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingCount.%{{.ShardingKeyTypeFormat}}】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}c.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, Condition{{.ShardingKey}}(sharding)(c.core))
			cr := cq.WithContext(ctx)
			if c.writeDB {
				cr = cr.WriteDB()
			}
			if c.unscoped {
				cr = cr.Unscoped()
			}
			if len(c.scopes) > 0 {
				cr = cr.Scopes(c.scopes...)
			}
			count, err := cr.Where(_conditions...).Count()
			if err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					c.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingCount.%{{.ShardingKeyTypeFormat}}】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				errChan {{.ChanSign}} err
				return
			}
			sm.Store(sharding, count)
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case {{.ChanSign}}endChan:
		count := int64(0)
		m := make(map[{{.ShardingKeyType}}]int64, _lenSharding)
		sm.Range(func(key, value interface{}) bool {
			v := value.(int64)
			m[key.({{.ShardingKeyType}})] = v
			count += v
			return true
		})
		return count, m, nil
	case err := {{.ChanSign}}errChan:
		return 0, nil, err
	}
}
`
}

func (r *Repository) genShardingCreateTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

	"{{.ModelPkg}}"
)

type _shardingCreate struct {
	core      *{{.StructName}}
	tx        *query.Query
	qTx       *query.QueryTx
	unscoped  bool
	values    []*{{.ModelName}}.{{.StructName}}
	batchSize int
	scopes    []func(gen.Dao) gen.Dao
}

// ShardingCreate 分表添加数据
func ({{.Abbr}} *{{.StructName}}) ShardingCreate() *_shardingCreate {
	return &_shardingCreate{
		core:     {{.Abbr}},
		unscoped: {{.Abbr}}.unscoped,
		values:   make([]*{{.ModelName}}.{{.StructName}}, 0),
		scopes:   make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (c *_shardingCreate) Tx(tx *query.Query) *_shardingCreate {
	c.tx = tx
	if tx != nil {
		c.qTx = nil
	}
	return c
}

// QueryTx 设置为手动事务
func (c *_shardingCreate) QueryTx(tx *query.QueryTx) *_shardingCreate {
	c.qTx = tx
	if tx != nil {
		c.tx = nil
	}
	return c
}

func (c *_shardingCreate) Unscoped() *_shardingCreate {
	c.unscoped = true
	return c
}

func (c *_shardingCreate) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingCreate {
	c.scopes = append(c.scopes, funcs...)
	return c
}

func (c *_shardingCreate) Values(values ...*{{.ModelName}}.{{.StructName}}) *_shardingCreate {
	c.values = append(c.values, values...)
	return c
}

// BatchSize 当批量插入时指定创建的数量
func (c *_shardingCreate) BatchSize(batchSize uint) *_shardingCreate {
	c.batchSize = int(batchSize)
	return c
}

// Do 执行添加数据
func (c *_shardingCreate) Do(ctx context.Context) (err error) {
	length := len(c.values)
	if length == 0 {
		return nil
	}
	bs := uint(c.batchSize)
	if length == 1 {
		cr := c.core.Create().Tx(c.tx).QueryTx(c.qTx).BatchSize(bs).Values(c.values...).Scopes(c.scopes...)
		if c.unscoped {
			cr = cr.Unscoped()
		}
		return cr.Do(ctx)
	}
	m := make(map[{{.ShardingKeyType}}][]*{{.ModelName}}.{{.StructName}}, length)
	for _, value := range c.values {
		m[value.{{.ShardingKey}}] = append(m[value.{{.ShardingKey}}], value)
	}
	if len(m) == 1 {
		cr := c.core.Create().Tx(c.tx).QueryTx(c.qTx).BatchSize(bs).Values(c.values...).Scopes(c.scopes...)
		if c.unscoped {
			cr = cr.Unscoped()
		}
		return cr.Do(ctx)
	}
	if c.tx != nil || c.qTx != nil {
		for _, values := range m {
			cr := c.core.Create().Tx(c.tx).QueryTx(c.qTx).BatchSize(bs).Values(values...).Scopes(c.scopes...)
			if c.unscoped {
				cr = cr.Unscoped()
			}
			if err = cr.Do(ctx); err != nil {
				return
			}
		}
		return
	}
	return c.core.q.Transaction(func(tx *query.Query) (err error) {
		defer func() {
			if r := recover(); r != nil {
				c.core.logger.Error("【{{.StructName}}.ShardingCreate】执行异常", zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
				err = fmt.Errorf("recovered from panic: %v", r)
				return
			}
		}()
		for _, values := range m {
			cr := c.core.Create().Tx(tx).BatchSize(bs).Values(values...).Scopes(c.scopes...)
			if c.unscoped {
				cr = cr.Unscoped()
			}
			if err = cr.Do(ctx); err != nil {
				return
			}
		}
		return
	})
}
`
}

func (r *Repository) genShardingDeleteTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _shardingDelete struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingDelete 删除分表数据
func ({{.Abbr}} *{{.StructName}}) ShardingDelete(sharding []{{.ShardingKeyType}}) *_shardingDelete {
	return &_shardingDelete{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (d *_shardingDelete) Worker(worker chan struct{}) *_shardingDelete {
	if worker == nil {
		return d
	}
	d.worker = worker
	return d
}

// Tx 设置为事务
func (d *_shardingDelete) Tx(tx *query.Query) *_shardingDelete {
	d.tx = tx
	if tx != nil {
		d.qTx = nil
	}
	return d
}

// QueryTx 设置为手动事务
func (d *_shardingDelete) QueryTx(tx *query.QueryTx) *_shardingDelete {
	d.qTx = tx
	if tx != nil {
		d.tx = nil
	}
	return d
}

func (d *_shardingDelete) Unscoped() *_shardingDelete {
	d.unscoped = true
	return d
}

func (d *_shardingDelete) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingDelete {
	d.scopes = append(d.scopes, funcs...)
	return d
}

func (d *_shardingDelete) Where(opts ...ConditionOption) *_shardingDelete {
	d.conditionOpts = append(d.conditionOpts, opts...)
	return d
}

// Do 执行删除分表数据
func (d *_shardingDelete) Do(ctx context.Context) (int64, map[{{.ShardingKeyType}}]int64, error) {
	_lenSharding := len(d.sharding)
	if _lenSharding == 0 {
		return 0, nil, nil
	}
	dq := d.core.q.{{.StructName}}
	if d.tx != nil {
		dq = d.tx.{{.StructName}}
	}
	if d.qTx != nil {
		dq = d.qTx.{{.StructName}}
	}
	var innerTx *query.QueryTx
	var cancel context.CancelFunc
	if d.tx == nil && d.qTx == nil {
		innerTx = d.core.q.Begin()
		dq = innerTx.{{.StructName}}
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
	}
	var conditions []gen.Condition
	if _len := len(d.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range d.conditionOpts {
			conditions = append(conditions, opt(d.core))
		}
	}
	sm := sync.Map{}
	wg := sync.WaitGroup{}
	errChan := make(chan error)
	endChan := make(chan struct{})
	for _, sharding := range d.sharding {
		d.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		go func(sharding {{.ShardingKeyType}}) {
			defer func() {
				if r := recover(); r != nil {
					d.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingDelete.%{{.ShardingKeyTypeFormat}}】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}d.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, Condition{{.ShardingKey}}(sharding)(d.core))
			dr := dq.WithContext(ctx)
			if d.unscoped {
				dr = dr.Unscoped()
			}
			if len(d.scopes) > 0 {
				dr = dr.Scopes(d.scopes...)
			}
			res, err := dr.Where(_conditions...).Delete()
			if err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					d.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingDelete.%{{.ShardingKeyTypeFormat}}】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				errChan {{.ChanSign}} err
				return
			}
			sm.Store(sharding, res.RowsAffected)
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case {{.ChanSign}}endChan:
		if innerTx != nil {
			if err := innerTx.Commit(); err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					d.core.logger.Error("【{{.StructName}}.ShardingDelete.Commit】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				return 0, nil, err
			}
		}
		rowsAffected := int64(0)
		m := make(map[{{.ShardingKeyType}}]int64, _lenSharding)
		sm.Range(func(key, value interface{}) bool {
			v := value.(int64)
			m[key.({{.ShardingKeyType}})] = v
			rowsAffected += v
			return true
		})
		return rowsAffected, m, nil
	case err := {{.ChanSign}}errChan:
		if innerTx != nil {
			cancel()
			_ = innerTx.Rollback()
		}
		return 0, nil, err
	}
}
`
}

func (r *Repository) genShardingFirstTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"errors"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _shardingFirst struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingFirst 获取分表中随机第一条记录（主键升序）
func ({{.Abbr}} *{{.StructName}}) ShardingFirst(sharding []{{.ShardingKeyType}}) *_shardingFirst {
	return &_shardingFirst{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (f *_shardingFirst) Worker(worker chan struct{}) *_shardingFirst {
	if worker == nil {
		return f
	}
	f.worker = worker
	return f
}

// Tx 设置为事务
func (f *_shardingFirst) Tx(tx *query.Query) *_shardingFirst {
	f.tx = tx
	if tx != nil {
		f.qTx = nil
	}
	return f
}

// QueryTx 设置为手动事务
func (f *_shardingFirst) QueryTx(tx *query.QueryTx) *_shardingFirst {
	f.qTx = tx
	if tx != nil {
		f.tx = nil
	}
	return f
}

func (f *_shardingFirst) Select(field ...field.Expr) *_shardingFirst {
	f.selects = append(f.selects, field...)
	return f
}

func (f *_shardingFirst) ForUpdate() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return f
}

func (f *_shardingFirst) ForUpdateSkipLocked() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *_shardingFirst) ForUpdateNoWait() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *_shardingFirst) ForShare() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return f
}

func (f *_shardingFirst) ForShareSkipLocked() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *_shardingFirst) ForShareNoWait() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *_shardingFirst) Unscoped() *_shardingFirst {
	f.unscoped = true
	return f
}

func (f *_shardingFirst) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingFirst {
	f.scopes = append(f.scopes, funcs...)
	return f
}

func (f *_shardingFirst) Where(opts ...ConditionOption) *_shardingFirst {
	f.conditionOpts = append(f.conditionOpts, opts...)
	return f
}

func (f *_shardingFirst) WriteDB() *_shardingFirst {
	f.writeDB = true
	return f
}

// Do 执行获取分表中随机第一条记录（主键升序）
func (f *_shardingFirst) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	if len(f.sharding) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	fq := f.core.q.{{.StructName}}
	if f.tx != nil {
		fq = f.tx.{{.StructName}}
	}
	if f.qTx != nil {
		fq = f.qTx.{{.StructName}}
	}
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	var conditions []gen.Condition
	if _len := len(f.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range f.conditionOpts {
			conditions = append(conditions, opt(f.core))
		}
	}
	var fieldExpr []field.Expr
	if _len := len(f.selects); _len > 0 {
		fieldExpr = make([]field.Expr, 0, _len)
		if f.core.newTableName == nil {
			fieldExpr = append(fieldExpr, f.selects...)
		} else {
			for _, v := range f.selects {
				fieldExpr = append(fieldExpr, field.NewField(*f.core.newTableName, v.ColumnName().String()))
			}
		}
	}
	wg := sync.WaitGroup{}
	endChan := make(chan struct{})
	errChan := make(chan error)
	resultChan := make(chan *{{.ModelName}}.{{.StructName}})
	for _, sharding := range f.sharding {
		f.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		go func(sharding {{.ShardingKeyType}}) {
			defer func() {
				if r := recover(); r != nil {
					f.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingFirst.%{{.ShardingKeyTypeFormat}}】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}f.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, Condition{{.ShardingKey}}(sharding)(f.core))
			fr := fq.WithContext(ctx)
			if len(fieldExpr) > 0 {
				fr = fr.Select(fieldExpr...)
			}
			if f.writeDB {
				fr = fr.WriteDB()
			}
			if f.unscoped {
				fr = fr.Unscoped()
			}
			if len(f.scopes) > 0 {
				fr = fr.Scopes(f.scopes...)
			}
			if (f.tx != nil || f.qTx != nil) && f.lock != nil {
				fr = fr.Clauses(f.lock)
			}
			res, err := fr.Where(_conditions...).First()
			if err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					f.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingFirst.%{{.ShardingKeyTypeFormat}}】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				if !errors.Is(err, gorm.ErrRecordNotFound) {
					errChan {{.ChanSign}} err
				}
				return
			}
			resultChan {{.ChanSign}} res
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case res := {{.ChanSign}}resultChan:
		return res, nil
	case {{.ChanSign}}endChan:
		return nil, gorm.ErrRecordNotFound
	case err := {{.ChanSign}}errChan:
		return nil, err
	}
}
`
}

func (r *Repository) genShardingLastTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"errors"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _shardingLast struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingLast 获取分表中随机最后一条记录（主键降序）
func ({{.Abbr}} *{{.StructName}}) ShardingLast(sharding []{{.ShardingKeyType}}) *_shardingLast {
	return &_shardingLast{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (l *_shardingLast) Worker(worker chan struct{}) *_shardingLast {
	if worker == nil {
		return l
	}
	l.worker = worker
	return l
}

// Tx 设置为事务
func (l *_shardingLast) Tx(tx *query.Query) *_shardingLast {
	l.tx = tx
	if tx != nil {
		l.qTx = nil
	}
	return l
}

// QueryTx 设置为手动事务
func (l *_shardingLast) QueryTx(tx *query.QueryTx) *_shardingLast {
	l.qTx = tx
	if tx != nil {
		l.tx = nil
	}
	return l
}

func (l *_shardingLast) Select(field ...field.Expr) *_shardingLast {
	l.selects = append(l.selects, field...)
	return l
}

func (l *_shardingLast) ForUpdate() *_shardingLast {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *_shardingLast) ForUpdateSkipLocked() *_shardingLast {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_shardingLast) ForUpdateNoWait() *_shardingLast {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_shardingLast) ForShare() *_shardingLast {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *_shardingLast) ForShareSkipLocked() *_shardingLast {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_shardingLast) ForShareNoWait() *_shardingLast {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_shardingLast) Unscoped() *_shardingLast {
	l.unscoped = true
	return l
}

func (l *_shardingLast) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingLast {
	l.scopes = append(l.scopes, funcs...)
	return l
}

func (l *_shardingLast) Where(opts ...ConditionOption) *_shardingLast {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

func (l *_shardingLast) WriteDB() *_shardingLast {
	l.writeDB = true
	return l
}

// Do 执行获取分表中随机最后一条记录（主键降序）
func (l *_shardingLast) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	if len(l.sharding) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	lq := l.core.q.{{.StructName}}
	if l.tx != nil {
		lq = l.tx.{{.StructName}}
	}
	if l.qTx != nil {
		lq = l.qTx.{{.StructName}}
	}
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	var conditions []gen.Condition
	if _len := len(l.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range l.conditionOpts {
			conditions = append(conditions, opt(l.core))
		}
	}
	var fieldExpr []field.Expr
	if _len := len(l.selects); _len > 0 {
		fieldExpr = make([]field.Expr, 0, _len)
		if l.core.newTableName == nil {
			fieldExpr = append(fieldExpr, l.selects...)
		} else {
			for _, v := range l.selects {
				fieldExpr = append(fieldExpr, field.NewField(*l.core.newTableName, v.ColumnName().String()))
			}
		}
	}
	wg := sync.WaitGroup{}
	endChan := make(chan struct{})
	errChan := make(chan error)
	resultChan := make(chan *{{.ModelName}}.{{.StructName}})
	for _, sharding := range l.sharding {
		l.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		go func(sharding {{.ShardingKeyType}}) {
			defer func() {
				if r := recover(); r != nil {
					l.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingLast.%{{.ShardingKeyTypeFormat}}】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}l.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, Condition{{.ShardingKey}}(sharding)(l.core))
			lr := lq.WithContext(ctx)
			if len(fieldExpr) > 0 {
				lr = lr.Select(fieldExpr...)
			}
			if l.writeDB {
				lr = lr.WriteDB()
			}
			if l.unscoped {
				lr = lr.Unscoped()
			}
			if len(l.scopes) > 0 {
				lr = lr.Scopes(l.scopes...)
			}
			if (l.tx != nil || l.qTx != nil) && l.lock != nil {
				lr = lr.Clauses(l.lock)
			}
			res, err := lr.Where(_conditions...).Last()
			if err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					l.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingLast.%{{.ShardingKeyTypeFormat}}】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				if !errors.Is(err, gorm.ErrRecordNotFound) {
					errChan {{.ChanSign}} err
				}
				return
			}
			resultChan {{.ChanSign}} res
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case res := {{.ChanSign}}resultChan:
		return res, nil
	case {{.ChanSign}}endChan:
		return nil, gorm.ErrRecordNotFound
	case err := {{.ChanSign}}errChan:
		return nil, err
	}
}
`
}

func (r *Repository) genShardingListTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	page "github.com/gorm-gen/paginate/gen"
	"github.com/gorm-gen/sharding/query/list"{{.DecimalPkg}}
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _shardingList struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	offset        int64
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	asc           bool
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingList 获取分表数据列表
func ({{.Abbr}} *{{.StructName}}) ShardingList(sharding []{{.ShardingKeyType}}) *_shardingList {
	return &_shardingList{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (l *_shardingList) Worker(worker chan struct{}) *_shardingList {
	if worker == nil {
		return l
	}
	l.worker = worker
	return l
}

// Offset 单表单次查询最多一次查询多少条数据
func (l *_shardingList) Offset(offset int64) *_shardingList {
	if offset > 0 {
		l.offset = offset
	}
	return l
}

// Desc sharding列表倒序
func (l *_shardingList) Desc() *_shardingList {
	l.asc = false
	return l
}

// Asc sharding列表正序
func (l *_shardingList) Asc() *_shardingList {
	l.asc = true
	return l
}

// Tx 设置为事务
func (l *_shardingList) Tx(tx *query.Query) *_shardingList {
	l.tx = tx
	if tx != nil {
		l.qTx = nil
	}
	return l
}

// QueryTx 设置为手动事务
func (l *_shardingList) QueryTx(tx *query.QueryTx) *_shardingList {
	l.qTx = tx
	if tx != nil {
		l.tx = nil
	}
	return l
}

func (l *_shardingList) Select(field ...field.Expr) *_shardingList {
	l.selects = append(l.selects, field...)
	return l
}

func (l *_shardingList) ForUpdate() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *_shardingList) ForUpdateSkipLocked() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_shardingList) ForUpdateNoWait() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_shardingList) ForShare() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *_shardingList) ForShareSkipLocked() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_shardingList) ForShareNoWait() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_shardingList) Unscoped() *_shardingList {
	l.unscoped = true
	return l
}

func (l *_shardingList) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingList {
	l.scopes = append(l.scopes, funcs...)
	return l
}

func (l *_shardingList) Order(opts ...OrderOption) *_shardingList {
	l.orderOpts = append(l.orderOpts, opts...)
	return l
}

func (l *_shardingList) Where(opts ...ConditionOption) *_shardingList {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

// Page 列表分页
func (l *_shardingList) Page(page, pageSize uint) *_shardingList {
	l.page = int(page)
	l.pageSize = int(pageSize)
	return l
}

func (l *_shardingList) WriteDB() *_shardingList {
	l.writeDB = true
	return l
}

// Do 执行获取分表数据列表
func (l *_shardingList) Do(ctx context.Context) ([]*{{.ModelName}}.{{.StructName}}, int64, error) {
	empty := make([]*{{.ModelName}}.{{.StructName}}, 0)
	_lenSharding := len(l.sharding)
	if _lenSharding == 0 {
		return empty, 0, nil
	}
	// 获取分表数据总记录
	shardingCount := l.core.ShardingCount(l.sharding).
		Worker(l.worker).
		Tx(l.tx).
		QueryTx(l.qTx).
		Where(l.conditionOpts...)
	if l.unscoped {
		shardingCount = shardingCount.Unscoped()
	}
	count, m, err := shardingCount.Do(ctx)
	if err != nil {
		return nil, 0, err
	}
	if count == 0 {
		return empty, 0, nil
	}
	// 获取分表分页数据
	svs := make([]*list.St, 0, _lenSharding)
	for k, v := range m {
		svs = append(svs, &list.St{
			ShardingValue: {{.ToShardingValue}},
			Total:         uint64(v),
		})
	}
	listOpts := []list.Option{
		list.WithPage(uint64(l.page)),
		list.WithPageSize(uint64(l.pageSize)),
	}
	if l.offset > 0 {
		listOpts = append(listOpts, list.WithOffset(uint64(l.offset)))
	}
	if l.asc {
		listOpts = append(listOpts, list.WithAsc())
	} else {
		listOpts = append(listOpts, list.WithDesc())
	}
	slList := list.New(svs, listOpts...).Analysis()
	slList.ToSliceIndex()
	// 获取分表数据
	lq := l.core.q.{{.StructName}}
	if l.tx != nil {
		lq = l.tx.{{.StructName}}
	}
	if l.qTx != nil {
		lq = l.qTx.{{.StructName}}
	}
	var conditions []gen.Condition
	if _len := len(l.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range l.conditionOpts {
			conditions = append(conditions, opt(l.core))
		}
	}
	var fieldExpr []field.Expr
	if _len := len(l.selects); _len > 0 {
		fieldExpr = make([]field.Expr, 0, _len)
		if l.core.newTableName == nil {
			fieldExpr = append(fieldExpr, l.selects...)
		} else {
			for _, v := range l.selects {
				fieldExpr = append(fieldExpr, field.NewField(*l.core.newTableName, v.ColumnName().String()))
			}
		}
	}
	var orders []field.Expr
	if _len := len(l.orderOpts); _len > 0 {
		orders = make([]field.Expr, 0, _len)
		for _, opt := range l.orderOpts {
			orders = append(orders, opt(l.core))
		}
	}
	wg := sync.WaitGroup{}
	_count_ := int64(0)
	_list_ := make([][]*{{.ModelName}}.{{.StructName}}, len(slList))
	endChan := make(chan struct{})
	errChan := make(chan error)
	for k, v := range slList {
		l.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		_count_ += v.Num
		go func(k int, v list.Sl) {
			defer func() {
				if r := recover(); r != nil {
					l.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingList.%s】执行异常-1", v.ShardingValue), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}l.worker
			}()
			defer wg.Done()
			_wg := &sync.WaitGroup{}
			_endChan := make(chan struct{})
			_errChan := make(chan error)
			__list := make([][]*{{.ModelName}}.{{.StructName}}, len(v.List))
			for kk, vv := range v.List {
				l.worker {{.ChanSign}} struct{}{}
				_wg.Add(1)
				go func(kk int, vv list.Sld) {
					defer func() {
						if r := recover(); r != nil {
							l.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingList.%s】执行异常-2", v.ShardingValue), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
							_errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
						}
					}()
					defer func() {
						{{.ChanSign}}l.worker
					}()
					defer _wg.Done()
					_conditions := make([]gen.Condition, len(conditions))
					copy(_conditions, conditions)
					{{.ShardingValueTo}}
					_conditions = append(_conditions, Condition{{.ShardingKey}}(shardingValue)(l.core))
					lr := lq.WithContext(ctx)
					if len(fieldExpr) > 0 {
						lr = lr.Select(fieldExpr...)
					}
					if l.writeDB {
						lr = lr.WriteDB()
					}
					if l.unscoped {
						lr = lr.Unscoped()
					}
					if len(l.scopes) > 0 {
						lr = lr.Scopes(l.scopes...)
					}
					if (l.tx != nil || l.qTx != nil) && l.lock != nil {
						lr = lr.Clauses(l.lock)
					}
					lr = lr.Where(_conditions...)
					if len(orders) > 0 {
						lr = lr.Order(orders...)
					}
					var res []*{{.ModelName}}.{{.StructName}}
					if res, err = lr.Scopes(page.Paginate(vv.Page, vv.PageSize)).Find(); err != nil {
						if {{.RepoPkgName}}.IsRealErr(err) {
							l.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingList.%s】失败", v.ShardingValue), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
						}
						_errChan {{.ChanSign}} err
						return
					}
					__list[kk] = res[vv.Start:vv.End]
				}(kk, vv)
			}
			go func() {
				_wg.Wait()
				_endChan {{.ChanSign}} struct{}{}
			}()
			select {
			case {{.ChanSign}}_endChan:
				___list := make([]*{{.ModelName}}.{{.StructName}}, 0, v.Num)
				for _, vvv := range __list {
					___list = append(___list, vvv...)
				}
				_list_[k] = ___list
				return
			case err = {{.ChanSign}}_errChan:
				errChan {{.ChanSign}} err
				return
			}
		}(k, v)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case {{.ChanSign}}endChan:
		__list := make([]*{{.ModelName}}.{{.StructName}}, 0, _count_)
		for _, v := range _list_ {
			__list = append(__list, v...)
		}
		return __list, count, nil
	case err = {{.ChanSign}}errChan:
		return nil, 0, err
	}
}
`
}

func (r *Repository) genShardingSumTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"github.com/shopspring/decimal"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _shardingSum struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	genField      field.Expr
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingSum 分表SUM数据
func ({{.Abbr}} *{{.StructName}}) ShardingSum(genField field.Expr, sharding []{{.ShardingKeyType}}) *_shardingSum {
	return &_shardingSum{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		genField:      genField,
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (s *_shardingSum) Worker(worker chan struct{}) *_shardingSum {
	if worker == nil {
		return s
	}
	s.worker = worker
	return s
}

// Tx 设置为事务
func (s *_shardingSum) Tx(tx *query.Query) *_shardingSum {
	s.tx = tx
	if tx != nil {
		s.qTx = nil
	}
	return s
}

// QueryTx 设置为手动事务
func (s *_shardingSum) QueryTx(tx *query.QueryTx) *_shardingSum {
	s.qTx = tx
	if tx != nil {
		s.tx = nil
	}
	return s
}

func (s *_shardingSum) Unscoped() *_shardingSum {
	s.unscoped = true
	return s
}

func (s *_shardingSum) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingSum {
	s.scopes = append(s.scopes, funcs...)
	return s
}

func (s *_shardingSum) Where(opts ...ConditionOption) *_shardingSum {
	s.conditionOpts = append(s.conditionOpts, opts...)
	return s
}

func (s *_shardingSum) WriteDB() *_shardingSum {
	s.writeDB = true
	return s
}

// Do 执行分表SUM数据
func (s *_shardingSum) Do(ctx context.Context) (decimal.Decimal, map[{{.ShardingKeyType}}]decimal.Decimal, error) {
	_lenSharding := len(s.sharding)
	if _lenSharding == 0 {
		return decimal.Zero, nil, nil
	}
	sq := s.core.q.{{.StructName}}
	if s.tx != nil {
		sq = s.tx.{{.StructName}}
	}
	if s.qTx != nil {
		sq = s.qTx.{{.StructName}}
	}
	var conditions []gen.Condition
	if _len := len(s.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range s.conditionOpts {
			conditions = append(conditions, opt(s.core))
		}
	}
	expr := field.NewField("", s.genField.ColumnName().String()).Sum().As("sum")
	wg := sync.WaitGroup{}
	sm := sync.Map{}
	errChan := make(chan error)
	endChan := make(chan struct{})
	for _, sharding := range s.sharding {
		s.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		go func(sharding {{.ShardingKeyType}}) {
			defer func() {
				if r := recover(); r != nil {
					s.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingSum.%{{.ShardingKeyTypeFormat}}】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}s.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, Condition{{.ShardingKey}}(sharding)(s.core))
			sr := sq.WithContext(ctx).Select(expr)
			if s.writeDB {
				sr = sr.WriteDB()
			}
			if s.unscoped {
				sr = sr.Unscoped()
			}
			if len(s.scopes) > 0 {
				sr = sr.Scopes(s.scopes...)
			}
			var data Sum
			if err := sr.Where(_conditions...).Scan(&data); err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					s.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingSum.%{{.ShardingKeyTypeFormat}}】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				errChan {{.ChanSign}} err
				return
			}
			sm.Store(sharding, data.Sum)
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case {{.ChanSign}}endChan:
		sum := decimal.Zero
		m := make(map[{{.ShardingKeyType}}]decimal.Decimal, _lenSharding)
		sm.Range(func(key, value interface{}) bool {
			v := value.(decimal.Decimal)
			m[key.({{.ShardingKeyType}})] = v
			sum = sum.Add(v)
			return true
		})
		return sum, m, nil
	case err := {{.ChanSign}}errChan:
		return decimal.Zero, nil, err
	}
}
`
}

func (r *Repository) genShardingTakeTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"errors"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"

	"{{.ModelPkg}}"
)

type _shardingTake struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingTake 获取分表中随机一条记录
func ({{.Abbr}} *{{.StructName}}) ShardingTake(sharding []{{.ShardingKeyType}}) *_shardingTake {
	return &_shardingTake{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (t *_shardingTake) Worker(worker chan struct{}) *_shardingTake {
	if worker == nil {
		return t
	}
	t.worker = worker
	return t
}

// Tx 设置为事务
func (t *_shardingTake) Tx(tx *query.Query) *_shardingTake {
	t.tx = tx
	if tx != nil {
		t.qTx = nil
	}
	return t
}

// QueryTx 设置为手动事务
func (t *_shardingTake) QueryTx(tx *query.QueryTx) *_shardingTake {
	t.qTx = tx
	if tx != nil {
		t.tx = nil
	}
	return t
}

func (t *_shardingTake) Select(field ...field.Expr) *_shardingTake {
	t.selects = append(t.selects, field...)
	return t
}

func (t *_shardingTake) ForUpdate() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return t
}

func (t *_shardingTake) ForUpdateSkipLocked() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_shardingTake) ForUpdateNoWait() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_shardingTake) ForShare() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return t
}

func (t *_shardingTake) ForShareSkipLocked() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_shardingTake) ForShareNoWait() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_shardingTake) Unscoped() *_shardingTake {
	t.unscoped = true
	return t
}

func (t *_shardingTake) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingTake {
	t.scopes = append(t.scopes, funcs...)
	return t
}

func (t *_shardingTake) Order(opts ...OrderOption) *_shardingTake {
	t.orderOpts = append(t.orderOpts, opts...)
	return t
}

func (t *_shardingTake) Where(opts ...ConditionOption) *_shardingTake {
	t.conditionOpts = append(t.conditionOpts, opts...)
	return t
}

func (t *_shardingTake) WriteDB() *_shardingTake {
	t.writeDB = true
	return t
}

// Do 执行获取分表中随机一条记录
func (t *_shardingTake) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	if len(t.sharding) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	tq := t.core.q.{{.StructName}}
	if t.tx != nil {
		tq = t.tx.{{.StructName}}
	}
	if t.qTx != nil {
		tq = t.qTx.{{.StructName}}
	}
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	var conditions []gen.Condition
	if _len := len(t.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range t.conditionOpts {
			conditions = append(conditions, opt(t.core))
		}
	}
	var fieldExpr []field.Expr
	if _len := len(t.selects); _len > 0 {
		fieldExpr = make([]field.Expr, 0, _len)
		if t.core.newTableName == nil {
			fieldExpr = append(fieldExpr, t.selects...)
		} else {
			for _, v := range t.selects {
				fieldExpr = append(fieldExpr, field.NewField(*t.core.newTableName, v.ColumnName().String()))
			}
		}
	}
	var orders []field.Expr
	if _len := len(t.orderOpts); _len > 0 {
		orders = make([]field.Expr, 0, _len)
		for _, opt := range t.orderOpts {
			orders = append(orders, opt(t.core))
		}
	}
	wg := sync.WaitGroup{}
	endChan := make(chan struct{})
	errChan := make(chan error)
	resultChan := make(chan *{{.ModelName}}.{{.StructName}})
	for _, sharding := range t.sharding {
		t.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		go func(sharding {{.ShardingKeyType}}) {
			defer func() {
				if r := recover(); r != nil {
					t.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingTake.%{{.ShardingKeyTypeFormat}}】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}t.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, Condition{{.ShardingKey}}(sharding)(t.core))
			tr := tq.WithContext(ctx)
			if len(fieldExpr) > 0 {
				tr = tr.Select(fieldExpr...)
			}
			if t.writeDB {
				tr = tr.WriteDB()
			}
			if t.unscoped {
				tr = tr.Unscoped()
			}
			if len(t.scopes) > 0 {
				tr = tr.Scopes(t.scopes...)
			}
			if (t.tx != nil || t.qTx != nil) && t.lock != nil {
				tr = tr.Clauses(t.lock)
			}
			tr = tr.Where(_conditions...)
			if len(orders) > 0 {
				tr = tr.Order(orders...)
			}
			res, err := tr.Take()
			if err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					t.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingTake.%{{.ShardingKeyTypeFormat}}】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				if !errors.Is(err, gorm.ErrRecordNotFound) {
					errChan {{.ChanSign}} err
				}
				return
			}
			resultChan {{.ChanSign}} res
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case res := {{.ChanSign}}resultChan:
		return res, nil
	case {{.ChanSign}}endChan:
		return nil, gorm.ErrRecordNotFound
	case err := {{.ChanSign}}errChan:
		return nil, err
	}
}
`
}

func (r *Repository) genShardingUpdateTemplate() string {
	return `// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type _shardingUpdate struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	updateOpts    []UpdateOption
	conditionOpts []ConditionOption
	sharding      []{{.ShardingKeyType}}
	worker        chan struct{}
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingUpdate 更新分表数据
func ({{.Abbr}} *{{.StructName}}) ShardingUpdate(sharding []{{.ShardingKeyType}}) *_shardingUpdate {
	return &_shardingUpdate{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
		updateOpts:    make([]UpdateOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
	}
}

func (u *_shardingUpdate) Worker(worker chan struct{}) *_shardingUpdate {
	if worker == nil {
		return u
	}
	u.worker = worker
	return u
}

// Tx 设置为事务
func (u *_shardingUpdate) Tx(tx *query.Query) *_shardingUpdate {
	u.tx = tx
	if tx != nil {
		u.qTx = nil
	}
	return u
}

// QueryTx 设置为手动事务
func (u *_shardingUpdate) QueryTx(tx *query.QueryTx) *_shardingUpdate {
	u.qTx = tx
	if tx != nil {
		u.tx = nil
	}
	return u
}

func (u *_shardingUpdate) Unscoped() *_shardingUpdate {
	u.unscoped = true
	return u
}

func (u *_shardingUpdate) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingUpdate {
	u.scopes = append(u.scopes, funcs...)
	return u
}

func (u *_shardingUpdate) Update(opts ...UpdateOption) *_shardingUpdate {
	u.updateOpts = append(u.updateOpts, opts...)
	return u
}

func (u *_shardingUpdate) Where(opts ...ConditionOption) *_shardingUpdate {
	u.conditionOpts = append(u.conditionOpts, opts...)
	return u
}

// Do 执行更新分表数据
func (u *_shardingUpdate) Do(ctx context.Context) (int64, map[{{.ShardingKeyType}}]int64, error) {
	_lenSharding := len(u.sharding)
	_lenUpdate := len(u.updateOpts)
	if _lenUpdate == 0 || _lenSharding == 0 {
		return 0, nil, nil
	}
	uq := u.core.q.{{.StructName}}
	if u.tx != nil {
		uq = u.tx.{{.StructName}}
	}
	if u.qTx != nil {
		uq = u.qTx.{{.StructName}}
	}
	var innerTx *query.QueryTx
	var cancel context.CancelFunc
	if u.tx == nil && u.qTx == nil {
		innerTx = u.core.q.Begin()
		uq = innerTx.{{.StructName}}
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
	}
	var conditions []gen.Condition
	if _len := len(u.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range u.conditionOpts {
			conditions = append(conditions, opt(u.core))
		}
	}
	columns := make([]field.AssignExpr, 0, _lenUpdate)
	for _, opt := range u.updateOpts {
		columns = append(columns, opt(u.core))
	}
	if len(columns) == 0 {
		return 0, nil, nil
	}
	sm := sync.Map{}
	wg := sync.WaitGroup{}
	errChan := make(chan error)
	endChan := make(chan struct{})
	for _, sharding := range u.sharding {
		u.worker {{.ChanSign}} struct{}{}
		wg.Add(1)
		go func(sharding {{.ShardingKeyType}}) {
			defer func() {
				if r := recover(); r != nil {
					u.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingUpdate.%{{.ShardingKeyTypeFormat}}】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan {{.ChanSign}} fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				{{.ChanSign}}u.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, Condition{{.ShardingKey}}(sharding)(u.core))
			ur := uq.WithContext(ctx)
			if u.unscoped {
				ur = ur.Unscoped()
			}
			if len(u.scopes) > 0 {
				ur = ur.Scopes(u.scopes...)
			}
			res, err := ur.Where(_conditions...).UpdateSimple(columns...)
			if err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					u.core.logger.Error(fmt.Sprintf("【{{.StructName}}.ShardingUpdate.%{{.ShardingKeyTypeFormat}}】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				errChan {{.ChanSign}} err
				return
			}
			sm.Store(sharding, res.RowsAffected)
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan {{.ChanSign}} struct{}{}
	}()
	select {
	case {{.ChanSign}}endChan:
		if innerTx != nil {
			if err := innerTx.Commit(); err != nil {
				if {{.RepoPkgName}}.IsRealErr(err) {
					d.core.logger.Error("【{{.StructName}}.ShardingUpdate.Commit】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				return 0, nil, err
			}
		}
		rowsAffected := int64(0)
		m := make(map[{{.ShardingKeyType}}]int64, _lenSharding)
		sm.Range(func(key, value interface{}) bool {
			v := value.(int64)
			m[key.({{.ShardingKeyType}})] = v
			rowsAffected += v
			return true
		})
		return rowsAffected, m, nil
	case err := {{.ChanSign}}errChan:
		if innerTx != nil {
			cancel()
			_ = innerTx.Rollback()
		}
		return 0, nil, err
	}
}
`
}
